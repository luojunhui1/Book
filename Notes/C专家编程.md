# C专家编程

## 1. 特性 or Bug

### 	1.1 误做之过

---

**strlen()**

在C语言的设计中，有一些语言特性并不适合实际开发，这些就是“误做之过”。

有一些函数的使用略微有点“反人类”，比如常见的函数：

```c++
extern unsigned int strlen(char *s);
```

无论在什么时候，当我们看见类似于如下的写法时，我们都应当认为它是错误的：

```c++
malloc(strlen(str))
```

这么说的原因是，一个字符串的长度在意义上应当是strlen(str) + 1，而不是strlen(str),所以它应当被书写成如下形式，这就是C语言在设计库函数时的问题，它当然也可以被认为是程序员的问题，不过明显这个函数的设计也并不合理。

```c++
malloc(strlen(str) + 1)
```

<!--more-->

**运算符复用、优先级、结合性**

这个问题主要在于C语言中可以说是过度的运算符重载，一方面这为它带来了简洁的语言特性，另一方面也带来了一堆令人迷惑的代码，比如：

```c++
p = N*sizeof*q
```

请问p是什么？

需要解答这个问题你至少需要几个知识：

1. sizeof是运算符而不是函数以及它的使用要求
2. \*q中的\*指的是乘法运算符还是解引用运算符

答案是p指的是*q指向类型的大小与N的乘值，这个例子能够简单地说明C中这种运算符复用可能会造成的问题，而至于优先级和结合性，他们带来的问题就是你很可能难以理解一个运算的次序或声明的含义，例如：

```c++
/*优先级和结合性说明了g()*h()组成一个意群，但没有说明它们内部的计算顺序，也没有指定f()和g()*h()的计算次序*/
X = f() + g()*h()

/*这是一个声明，请回答它声明了什么。优先级和结合性在声明里可能会造成的问题很明显了吧*/
char *(* c[10])(int **)p
```

解决方法也很简单：**多用括号！！！**

除以上之外，C语言中还有一些命名和它的实际使用对不上号的关键字，如virtual的实际意义是共享，const的实际意义更倾向于read only。

### 1.2 多做之过

C/C++标准在不断的更新过程中，虽然他们的宗旨是尽量少改变，不过还是会有一些改变，有些改变像你妈提醒你穿秋裤，事实是关心你，不过事实也是你觉得这对你毫无意义，标准委员会也会为程序员做这种“提醒穿秋裤”的事。

在ANSI C 中引入了一个特性，即相邻字符串会被自动合并为一个字符串，这样省去了如果一个字符串过长需要在换行处加上“\”的麻烦（其实也没那么麻烦），但这造成了一个问题，若声明一个字符串数组时，忘记了一个逗号，编译器并不会提醒你错误，就像下面这样：

```c++
#include <stdio.h>
#include <string.h>
int main()
{
    char *str[] = {"I", " am", " iron" "man"};
    printf("%s",str[2]);
    return 0;
}
```

输出如下(省略了一些warning)：

> ironman

---

**switch case**

在switch case语句中，它也常有一个令人诟病的特性：**case语句后需要显式加上break语句**。为什么这样说，在实际应用代码中（Sun ANSI C的编译器前端），只有3%的代码采用了switch case语句的“fall through”特性，而余下的代码都需要加上break语句，这样显著的使用情况差异，也反映了switch case这个“fall through”特性的鸡肋。而它的问题还不止这一个，由于在switch case语句中几乎可以不加限制地插入标签语句，这可能会造成一些混乱。

而关于break，还有一个常见的问题，break可能会经常被误用于if语句中用于跳出if语句，但它的真实应用是跳出离它最近的循环或switch语句，这样的印象可能会在不经意中带来一些bug。

### 1.3 少做之过

少做之过指的是语言理应提供但实际又未提供的一些特性，如标准参数处理等。

## 2. 限定符 与 类型相容

```c++
#include <iostream>

using namespace std;

void foo(const char **p)
{
    cout<<"In function foo"<<endl;
}

int main(int argc, char *argv[])
{
    foo(argv);
    return 0;
}
```

在这段代码中，若直接运行会报错 

>  error: invalid conversion from 'char\**' to 'const char\*\*'

要理解这个问题首先需要明确一条重要的标准和一条函数传参的约束：

*标准：***要使上述的赋值形式合法，必须满足以下条件之一：两个操作数都指向有限定符的相容类型的指针，左边指针指向的类型必须具有右边类型所指向类型的全部限定符**

*约束：***每个实参都应该具有自己的类型，这样它的值就可以赋值给它对应的形参类型的对象~~（该对象的类型不能有限定符）~~**

这个约束实际就是在说，函数传参的过程实际类似于赋值。知道了这样的规则和约束，再辅以一则能正确运行的代码作比较就可以清楚地分析这个问题了：

```c++
#include <iostream>

using namespace std;

void foo(const char *p)
{
    cout<<"In function foo"<<endl;
}

int main(int argc, char *argv[])
{
    /*在这段代码中值得一提的还有另一个问题，即指针和数组在作为形参和实参进行传递的问题，有个最基本的原则：
      函数并不知道什么数组和指针，它们一律被当作指针处理；在这里，若写为char *cur = "luojunhui"，则会
      报错，原因就是上面提到的标准，它们的类型不兼容，字符串常量类型为const char*， 而左边类型为char*,
      明显不符合上述规则，而char []实际上就是指针常量。更为具体的可参见以下博客：
      https://www.jianshu.com/p/a4d12ed9db11
    */
    char cur[] = "luojunhui";
    foo(cur);
    return 0;
}
```

|                        | 报错的代码（const char** 与 char**） | 正常的代码 （const char* 与 char*）  |
| ---------------------- | ------------------------------------ | ------------------------------------ |
| 实参                   | const char**                         | const char*                          |
| 形参                   | char**                               | char*                                |
| 实参指向类型           | const char*                          | const char                           |
| 形参指向类型           | char*                                | char                                 |
| 实参指向类型有无限定符 | 无（const char* 中的const 修饰char） | 有                                   |
| 指向类型是否相容       | 否（一个为const char* 一个为 char*） | 是（去掉限定符，考虑类型，都是char） |

## 3. 隐式类型转换的隐患

书中并没有直接提到这个这个问题，但他举的例子可以说明这个问题，C/C++中的隐式类型转换一直被很多程序员诟病，并且认为是一种落后的语言特性，这里将会展示它所造成的问题之一。

<img src="https://img-blog.csdn.net/20181011190643628?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Mzc3Mjc5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="type converte" style="zoom: 33%;" />

隐式类型转换会按上图的规则进行，这会造成可能计算的结果和直觉上的结果并不一样，尤其当程序员不注意数据类型或者想当然的情况，具体实验代码可以参考如下：

```c++
#include <stdio.h>

int main()
{
    int i = -2;
    unsigned int j = 1;
    
    if( (i + j) >= 0 )
    {
        printf("i+j>=0\n");
    }
    else
    {
        printf("i+j<0\n");
    }
    
    printf("i+j=%d\n", i + j);
	
    if(-1 < (unsigned char)1)
    {
        printf("-1 is less than (unsigned char)1: ANSI semantics");
    }    
    else
    {
        printf("-1 is NOT less than (unsigned char)1: K&R semantics");
    }
    return 0;
}
```

它的输出如下：
>i+j>=0
>i+j=-1
>-1 is less than (unsigned char)1: ANSI semantics

最后一行的输出很有意思，如果将代码中的（unsigned char）1换成(unsigned int)则会得到 -1 > (unsigned char)1的结果，这取决于具体的类型，不过实验下来，当改为(unsigned long long)1时，也会得到-1 > (unsigned char)1的结果，都符合ANSI C 标准。为了避免这些小细节造成不必要的BUG,**尽量不要使用无符号数，或者小心隐式转换！**

## 4. 声明！你真的看得懂吗？

​	C语言中有这样一种特性，**声明和使用形式在很多时候都一样**，相比于其它语言来说，它会使用一些操作符来指示数据的类型，如&符号既表示位运算与又表示引用，*符号既表示运算相乘又表示指针。

```c++
/*声明*/
int *p[20];

/*使用,输出p数组中第i个元素指向的数据的值*/
printf("%d\n",*p[i]);
```

这样做的好处很明显，数据在运算和在使用的时候的优先级都是一样的，对编译器来说相当于减小了负担，但对程序员来说，这么做会导致的问题是（原因也是操作符复用情况严重）程序员可能有时难以分析出一个声明到底是什么意思。这一情况在引入了一些限定符后更糟糕了，限定符作用的对象也需要仔细梳理才能知道，比如：

```c++
char * const *(*next)();
```

这实际上声明了一个指向 **返回值为char类型 的常量指针  的指针** *的函数* 的指针。

要分析一个声明，首先要知道声明中的优先级规则：

>1. 声明从它的名字开始读取，然后按照优先级规则依次读取
>2. 优先级从高到低为：
>   - 声明中被括号括起来的部分
>   - 后缀操作符
>     - 括号（）表示这是一个函数
>     - 方括号[]表示这是一个数组
>   - 前缀操作符
>     - 星号*表示指向…的指针
>3. 若const和volatile关键字的后面紧跟类型说明符（int，long等），则它作用于类型说明符，否则作用于它左边临近的指针

按照以上方法，稍加练习，你基本上就能理解大多数声明了。值得一提的是，有时“声明”这样的“操作”过于平常，一般程序员（不是设计编译器的那种）可能不会关注“声明”本身的语法结构， 我们将声明抽象为一个**声明器**，那么C语言中的声明器由很多部分组成:
$$
声明器 = \{（指针）[直接声明器]"初始化内容"【类型说明符】（,）[;]\}
\\ ()表示0个或多个
\\ []表示有且只有一个
\\ ""表示0个或一个
\\ 【】表示至少一个
$$

## 5. 用好typedef 和define

在简单的使用场景下typedef与define使用起来可以相互替换，比如：

```c++
#define _REAL_ int 

typedef int REAL
```

二者都为int类型取了别名，但它们的区别主要在于，前者在预编译期间通过文本替换来完成，后者则在编译期间通过编译器完成，并且，后者在这种为变量取别名的任务上明显更胜一筹。

define语句的主要优势在于它与其它在预编译期间的语句如#ifdef,#undef,#if，以及一些与#define命令搭配使用的特殊符号如#，##，@一起完成如控制代码块是否编译，定义一些在预编译期间需要完成的操作，定义一些简单函数的功能，以下是#define语句常见的使用场景：

```c++
/*1. 防止头文件重复包含*/
#ifndef BODYDEF_H 
#define BODYDEF_H 
 //头文件内容 
#endif

/*2. 定义一些简单的操作，以下是防止加法运算溢出的宏定义，常见的还有交换两个数的值，取变量地址等操作*/
#define INC_SAT( val ) (val = ((val)+1 > (val)) ? (val)+1 : (val))

/*3. 控制代码块是否编译,常见的用于调试模式*/
#define _DEBUG_

/*4. 与标准预定义宏搭配使用*/
__func__：在源代码中插入当前所在函数名；

__LINE__：在源代码中插入当前源代码行号；

__FILE__：在源文件中插入当前源文件名；

__DATE__：在源文件中插入当前的编译日期

__TIME__：在源文件中插入当前编译时间；

__STDC__：当要求程序严格遵循ANSI C标准时该标识被赋值为1；

__cplusplus：当编写C++程序时该标识符被定义。
    
/*5. 与#,##,@搭配使用*/
#define Conn(x,y) x##y
#define ToChar(x) #@x
#define ToString(x) #x    
```

对于typedef而言，它的常见的使用常见就是给结构体换一个方便使用的名字，如：

```c++
typedef struct PersonTag{...} Person;
```

但这么做的好处实在有限，用typedef来为某数据类型创建别名的优点主要有三个：

1. 它符合范围规则，即相同的作用域中不能出现同名的标识符，不在标识符作用范围内的代码无法使用typedef定义的标识符。

2. 在连续的变量声明中，使用typedef能保证声明中的所有变量都是同一种类型，如下：

   ```c++
   #define CHARPTR char*
   
   /*a为char*, b为char*/
   CHARPTR a,b;
   
   typedef char* CharPtr;
   /*a,b均为char**/
   CharPtr a,b;
   ```

3. typedef可以简化复杂的声明，只需在正常地声明中把变量变为类型名，再在前面加上关键字typedef即可

   ```c++
   /*signal()函数的声明如下,看不懂实属正常*/
   void (*signal(int sig, void(*func)(int)))(int);
   
   /*ptr_to_func表示一个接受一个int参数的返回值为void的函数指针*/
   typedef void(*ptr_to_func)(int);
   
   /*signal()函数现在可以改写如下*/
   ptr_to_func siganl(int, ptr_to_func)
   ```

   define语句和typedef语句为代码性能带来的提升可能微乎其微，但它们作为一种为程序员提供的撰写代码的技巧，提供了一种更优秀的编程风格的可能。

## 6. 指针 与 数组

### 6.1 什么时候二者相同

这个再说，一般是作为函数传参的时候。

### 6.2 什么时候二者不同

二者的不同之处其实很多，不过先举一个例子用于说明如果在使用时不注意二者的区别会造成什么后果：

```c++
/*a.h*/
char a[] = "123456";
char *b = "abcdefg";
/*b.h*/
extern char *a;
extern char b[];

...
/*定义为数组，声明为指针*/
a[3];//不能能得到正确结果，编译器首先取出a地址中的内容，将它作为了目标元素的起始地址，但实际上a本身所在的地址就是目标元素的起始地址

/*定义为指针，声明为数组,此时编译器知道b是一个指针*/
b[3]
```

上面这两行各自声明了一个指针和一个数组，不过他们的定义在别处，只不过需要在此处使用所以使用了extern声明，当它们的声明和定义类型相同时不会发生问题，但当它们不相同时，尤其在定义为数组，却以指针的声明使用时，会造成未定义的结果。

```c++
/*test1.c*/
char a[] = "123456";
char *b = "abcdefg";

/*test.c*/
#include <stdio.h>

extern char *a;
extern char b[];

int main()
{
    printf("TEST\n");

    printf("address b = %x\n",b);
    printf("b[3] = %x\n",b[3]);
    printf("b[3] = %c\n",b[3]);

    printf("address a = %x\n",a);
    printf("a[3] = %x\n",a[3]);
    printf("a[3] = %c\n",a[3]);

}

/*terminal*/
gcc -c test1.c -o test1.o
gcc -c test.c -o test.o
gcc test.o test1.o -o test -Wall -pedantic
./test

/*output*/
TEST
address b = 403018
b[3] = 0
b[3] =
address a = 34333231
```

从以上的测试结果中可以看出，当定义为数组而声明为指针引用时，指针的地址变成了ASCII码（34333231明显是1,2,3,4的ASCII码值，倒序是因为汇编中字符串的存放顺序是倒着的）,a[3]取不到或者没有读权限，程序未完全执行便退出了。

这里再补充声明和定义的区别：

>声明相当于普通的声明：用于描述对象的类型，它所说明的并非自身，而是描述其它地方创建的对象
>
>定义相当于特殊的声明，不过它为对象分配了内存
>
>**上述“对象”并不指C++中的对象，不然上面的解释就很难理解了，这里的对象指的是面向链接器的对象，如函数，变量一类的东西**

除以上之外，数组和指针还有以下区别：

| 指针                                                         | 数组                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 保存数据地址                                                 | 保存数据                                                     |
| 间接访问数据，指针本身占据一个4字节或8字节的长度保存一个地址，该地址指向目标数据，若用下标的形式访问元素，a[i]表示用指针中保存的地址+i获得目标元素 | 直接访问数据，数组本身的地址就是数据的起始地址，a[i]操作仅是a + i而已 |
| 常用于动态数据结构                                           | 常用于存储固定数目且类型元素相同的数据                       |
| 相关的函数为malloc()和free()                                 | 隐式分配和删除                                               |
| 通常指向匿名数据                                             | 自身极为数据名                                               |

需要特别注意的是：

>定义指针时，编译器一般不为指针分配存储空间，但当在定义指针同时使用了字符串来初始化，则会为其分配内存，但在ANSI C中，这种方法定义的字符串被存放在只允许被读取的文本段而不能修改。通过字符串初始的数组却可以通过数组修改。

## 7. 动态链接与静态链接

这一部分讲述二者的应用情况和inline关键字。

## 8. 面向面试学习

>由于突然被腾讯捞了，提前写一部分。

### 8.1如何检测到链表中存在循环

| 限制                                          | 方法                                                         |
| :-------------------------------------------- | ------------------------------------------------------------ |
| 无限制                                        | 对每个访问过的元素添加标记，遍历链表，当遇到某一做过标记的元素后，说明存在循环。 |
| 只可读                                        | 访问每个元素时，把它存在一个数组中，检查每一个后继元素，若它已经存在于数组中则存在循环。（这种方法的实现或许可以通过链表的元素的当前地址（在运行过程中，元素的地址是可以获得的）来确定在数组中的位置） |
| 内存有限，但假定一定有循环且出现在前n个元素中 | 设置指针对前n个元素中的每个元素都比较一遍                    |
| 链表长度任意，且循环可能出现在任意位置        | 快慢指针，使快指针一开始指向第三个元素且每次移动两个元素，慢指针一开始指向第一个元素且每次移动一个元素，若存在循环，则两个指针终有相等的时候。 |

### 8.2 C语言中不同增值语句的区别

```c++
x = x + 1;
++x;
x++;
x += 1;
```

这几句在现代编译器中的汇编代码均是：

```assembly
addl	$1, -4(%rbp)
```

所以在效率上它们并没有什么区别，在现代编译器中就不必在这个语句上对锱铢必较了，它们都应该是最快的指令。所以它们的区别主要在于使用情况的不同，这方面的区别已经是老生常谈，但还是需要知道++x和x++在实现过程上的区别，前者表示取x的地址，增加它的内容，再把值放入寄存器，后者表示取x的地址，取它的值放入寄存器，然后增加内存中x的值。而对于x += 1语句而言，需要注意的是“**左值仅计算一次**”，这点可以用以下示例直观理解：

```c++
mango[i++] += 1;
/*它应当等效于：*/
mango[i] = mango[i] + 1;i++;
/*而不是：*/
mango[i++] = mango[i++] + 1;
/*这点与左值的特性有关*/
```

### 8.3 库函数调用和系统调用的区别

| 库函数调用                            | 系统调用             |
| ------------------------------------- | -------------------- |
| 在所有ANSI C编译器版本中，C库函数相同 | 取决于操作系统       |
| 调用函数库中的一个程序                | 调用系统内核的服务   |
| 与用户程序相联系                      | 是操作系统的进入点   |
| 在用户地址空间执行                    | 在内核地址空间执行   |
| 运行时间属于用户时间                  | 运行时间属于内核时间 |
| 过程调用，开销小                      | 需要切换上下文       |
| 典型：system() malloc() fprintf()     | 典型：fork write brk |

### 	8.4 文件描述符与文件指针有何区别

简单来说，文件描述符用于Unix系统调用中，用于索引开放文件的每个进程表，通常是一个小整数用于表示偏移量。文件指针保存了一个FILE结构的地址，FILE结构用于表示开放的IO流，用于ANSI C标准的I/O库调用中，也用于标识文件。

### 8.5 有符号还是无符号？

```c++
#define ISUNSIGNED_VALUE(x) (x >=0 && ~x >=0)

#define ISUNSIGNED_TYPE(type) ((type)0 - 1 > 0)
```

用以上代码可判断一个类型或变量是有符号或者无符号，这在代码的移植性上可能有一些需要。