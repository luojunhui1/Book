# C和指针

本篇博客主要对自己读《C和指针》一书的过程作记录，不成整体，比较零碎。

## 快速上手

这一章作者通过一个例子来举例说明一些C语言基本的函数和概念，其中有几点值得记录下：

- 如果有一些声明需要用于多个源文件，可以将这些声明写在一个单独的文件中，在后续的使用中，只需要包含这一个文件即可，避免了在维护这些代码时出现错误的可能性。
- 标准未硬性规定C编译器对数组的下标进行检查，大多数编译器实际上也是这么做的，不过在实际的产品开发过程中，最好对数组的下标进行检查，~~即使是认为不可能的地方~~。
- **在实际上，当想使用&&的时候，千万不要误使用&操作符，后者实际执行”按位与“操作，二者在很多情况下都不一样。**
- 在使用库包含的变量时，需要仔细查看源代码，了解数据结构。例如EOF实际上是一个整型值，所以可以用int型来接受字符信息，再来判断是否为空，防止字符意外被解释为EOF。


## 基本概念

- 在编译并链接完全包含于一个源文件的C程序时，如

  ```c
  cc program.c
  ```

  会产生一个称为a.out的可执行程序(未用-o选项选定输出名称)，中间会产生一个名为program.o的目标文件，该目标文件会在链接过程完成后被删除。而当编译文件超过一个时，目标文件就不会被删除，这让我们在只修改了部分源文件时可以执行以下的操作：

  ```c
  cc main.o lookup.o sort.c
  ```

- **三字母词**。这个有些猎奇，现在基本上看不见这类问题，，有些编译器甚至不处理三字母词而只是当作普通字符串处理。

- 所有的注释都会被**预处理器**拿掉，取而代之的是一个空格。所以以下语句从技术上来说是没有问题的：

  ```c
  int/*comment*/x
  ```

- 绝大多数注释以块的形式出现，这样在视觉效果上更突出。

##  数据

- 尽管设计char类型是让它们容纳字符型值，但字符在本质上是小整型值，缺省的char要么是signed char 要么是 unsigned cha，这取决于编译器，这个事实实际上意味着不同机器的char可能有不同的取值范围，只有当一个char型变量的值处于signed char 和 unsigned char的交集中，这个程序才是可移植的。**但是**，许多处理字符的库函数将它们的参数声明为char，显式声明为signed或unsigned可能会带来兼容性问题。

- 对于字符常量来说，它们的类型总是int,不能在后面加上unsigned或long后缀。（字符常量就是一个用单引号包围起来的单个字符）

- 字符串常量的直接值是一个指针，即指向这些字符所存储的位置，而不是这些字符本身。

- 对于指针来说，很容易在声明的时候写成这种形式：int* a,这看起来很直观，即a是一个指向int型数据的指针，但正确规范的写法应该是：int *a,因为当你在同时声明多个指针时，int\* a,b,c,d;只有a是指针，其它都是变量，\*实际上只是表达式\*a的一部分。

- 应该用typedef而不是#define来创建新的类型名，因为后者无法正确地处理指针类型，例如：

  ```c
  #define ptr_to_char char*
  ptr_to_char a,b;
  ```

  a被正确地声明了，b却被声明为一个字符。

- 涉及到指针常量定义时，有一点需注意：int const *pci是一个指向整型常量的指针，可以修改指针的值，但是不能修改指针指向的值。相比之下，int * const cpic则声明一个指向整型的常量指针，此时指针是常量，它的值无法修改但可以修改它指向的整形的值。

- 标识符的**链接属性**有三种：none,internal和external，其中none链接属性的标识符总是被当作单独的个体，有多少个声明就有多少个多少个独立的实体。internal链接属性的标识符在同一个源文件的所有声明都指向同一个标实体，但位于不同源文件的多个标识符就分属不同的实体。external链接属性的标识符不论声明多少次、位于几个源文件都表示同一个实体。**关键词**extern和static用于在声明中修改标识符的链接属性.对于缺省链接属性为external的标识符，在它前面加上static可以将其链接属性改变为internal。当extern用于源文件标识符的第一次声明中时，它指定该标识符有external链接属性，但若它用于一个标识符的第二次或之后的声明时，并不会更改由第一次声明指定的链接属性。

- 对于自动变量来说，在声明变量的同时初始化和先声明后赋值只有风格之差，并无效率差别。原因是自动变量的地址在程序链接时还并不能确定位置，基于这个理由，自动变量没有缺省的初始值。

- 用于不同的上下文环境中时，static关键字有不同的意思。用于函数定义，或代码块之外的变量声明时，它用于修改链接属性，用于代码块内部的变量声明时，它用于修改存储类型（静态）。

## 语句

无

## 操作符和表达式

- 位操作符常与逻辑操作符混淆，但二者有着很大的不同，第一是后者有着**最短路性质**，若表达式根据左操作数就可决定，那么它就不对右操作数再求值，第二，逻辑操作符用于测试零值和非零值，而位操作符用于比较它们的操作数中对应的位。对于以下两条语句，a=1,b=2,二者的结果就不相同：

  ```c
  if(a&&b)
  if(a&b)
  ```

- **逗号操作符**。这种技巧在实际中很少见到。逗号操作符将两个或多个操作符分隔开来，这些表达式自左向右挨个求值，整个逗号表达式的值就是最后那个表达式的值。它可以这样应用：

  ```c
  while(a=get_value(),count_value(a),a>0)
  {
      /*content*/
  }
  ```

## 指针

​	指针的算术运算只限于两种形式，第一种为
$$
pointer\quad\pm\quad integer
$$
第二种为
$$
pointer\quad-\quad integer
$$
其中，第二种只有当两个指针指向同一个数组中的元素时，才允许这样操作，结果就是这两个指针对应元素下标之差。对指针执行**关系运算**亦有限制，他们只能是同一个数组中的元素（相等运算除外，可以是任意的指针），但标准允许数组元素指针与指向数组最后一个元素后面的那个内存位置的指针进行比较，但不允许与指向数组的第一个元素之前的那个内存位置的指针进行比较

```c
/*可行例*/
for(vp=&value[0];vp<&vp[N_VALUES];)
	*vp++ = 0;
	
/*错误例*/
for(vp=&value[N_VALUES-1];vp>&vp[0];vp--)
	*vp = 0;

```

但实际上，后者实际上在大多数编译器中，都可以顺利地执行，但标准并不保证它可行，为了代码的可移植性，还是应该避免这样的操作。

## 函数

- 从表达式内部调用一个过程类型的函（无返回值）是一个严重的错误，因为这样一来表达式的求值过程中会使用一个不可预测值的（垃圾）。（**现代编译器已经能捕捉这种类型的错误了**）

- 如果没有关于调用函数的特定信息，编译器便假定在这个函数的调用时，参数的类型和数量都是正确的。它同时会**假定函数将返回一个整型值**。对于那些返回值并非整型的函数而言，这种隐式认定时常导致错误。

- 对于上声明：

  ```c
  int *function()
  ```

  来说，它的形式有些含糊，它既可以看作是一个旧式风格的声明，也可以看作是一个没有参数的新风格的原型。而事实上，它必须被解释为旧式风格的声明，目的是保持ANSI标准与之前的程序的兼容性，一个没有参数的新式风格的声明应该写成如下的样子：

  ```c
  int function(void)
  ```

- 对于函数而言，C的规则很简单：**所有的参数都是传值调用**，你可能会想到数组或指针，但这两者实际上也只是传递了指针的拷贝而已。

- **可变参数列表**

  可变参数列表是通过宏来实现的，这些宏定义于stdarg.h文件中，它是标准库的一部分，这个头文件声明了一个类型va_list和三个宏va_start、va_arg和va_end。它的具体用法由下面的例子给出。但有一点要特别注意，由于在可变参数列表中，参数的原型，所以所有作为可变参数传递给函数的值都将执行**缺省参数类型提升**，这要求你在使用va_arg的时候要额外小心，如果在va_arg中指定错了类型，那么结果是不可预测的，char\float\short这些类型的参数实际将作为int或者double类型的值传递给参数。

  ```c
  #include <stdarg.h>
  #include <stdio.h>
  
  float
  average(int n,...)//至少有一个命名参数
  {
      va_list var_args;
      register int count;
      float sum = 0;
      /*准备访问可变参数,初始化，使用va_start*/
      va_start(var_args,n);
      /*取用可变参数的值,使用va_arg*/
      for(count = 0;count<n;count += 1)
      {
          sum += va_arg(var_args,int);
      }
      /*完成处理可变参数，使用va_end*/
      va_end(var_args);
      return sum/n;
  }
  int main()
  {
      //int num[] = {1,2,3,4,5,6,7,8,9};
      short a=1,b=2,c=3,d=4;
      printf("%.2f\n",average(9,1,2,3,4,5,6,7,8,9));
      printf("%.2f\n",average(4,1,2,3,4));/*short类型参数缺省参数提升为int型*/
      return 0;
  }
  /*
  输出：
  5.00
  2.50
  */
  ```

## 数组

- **数组和指针具有一些完全不同的属性，二者切不能混淆。**数组具有确定量的元素，而指针只是一个标量值。编译器用数组名来记住这些属性，只有当数组在表达式中使用时，编译器才会为它产生一个指针常量。

- 在程序完成链接后，内存中数组是固定的，所以当程序运行时，再想移动数组就晚了。也因此，**数组名的值是一个指针常量**。在两种场合下数组名并不用指针常量来表示，当数组名作为sizeof操作符或单目操作符&的操作符时。sizeof返回整个数组的长度，而不是指向数组的指针的长度，取一个数组名的地址所产生的是一个指向数组的指针，而不是指向某个指针常量的指针。所以，以下操作是错误的

  ```C
  int a[10];
  int *c;
  a = c;/*错误，左值是常量*/
  ```

- 书中提到了一个诡异的技巧。2[array]实际上相等于*(array+2)，这是由数组下标的实现方法决定的。

- **对于指针和下标两种方式来说，下标绝不会比指针更有效，但指针有时会比下标更有效率。**对于这句话的解释，作者在144至149页有相当精彩的解说，过程比较长，这里只说结果。

  - 当你根据某个固定数目的增量在一个数组中移动时，使用指针变量将比使用下标产生效率更高的代码。当这个增量是1并且机器具有自动增量模型时，这一点更为突出。
  - 声明为寄存器变量的指针通常比位于静态内存和堆栈中的指针效率更高
  - 那些必须在运行时求值的表达式较之诸如&array[SIZE]或array+SIZE这样的常量往往代价更高。

- 对于指针来说*a++这样的操作完全合法，对于数组来说则不是这样，因为后者为常量。

- 对于**字符数组**的初始化来说，有下面两种方法：

  ```c
  /*第一种*/
  char message[] = {'H','e','l','l','o',0};
  /*第二种*/
  char meaasge[] = "Hello"
  ```

  对于后者来说，它的右值看起来像是一个字符串常量，但实际上并不是，它是前例初始化列表的另一种写法，在其他任何地方，它都表示一个字符串常量。

- **多维数组**

  - 存储顺序

    多维数组的元素存储顺序按照最右边的下标率先变化的原则，称为**主序原则**。以下是数组在内存中的存储形式：

    ![数组在内存中的存储形式](https://cdn.jsdelivr.net/gh/luojunhui1/BlogPicture/Windows/20200913145819.png)

    所以对matrix\[3][9]来说，若*p = matrix\[1][8],则\*（p++）的操作是可行的，此时\*p表示的是matrix\[2][0]的值，这种技巧也称为“flatting the array”，但应当尽量避免。

  - **指向数组的指针**。这个概念尤为重要，它与指向指针的指针大不相同：

    ```c
    int vector[10], *vp = vector;
    int matrix[3][10],**mp = matrix;
    ```

    前者是正确的，后者是错误的，原因是mp是指向整型的指针的指针,而实际上mp应该是一个指向数组的指针，这点在多维数组作为函数参数时尤为明显，作为参数，多维数组除第一维长度可省略外，之后维度的长度都不可省略（这点是因为，第一维的长度并用不上），这些关系到指针的+1操作到底指的是什么和数组长度自动计算。int *p[10]和int （\*p）[10]的意义也完全不同，下标的优先级较高，前者表示长度为10的指针数组，元素类型为指向整型的指针,后者则是二维数组指针，每个数组的长度为10。

  - 只要有可能，函数的指针形参都应该声明为const。

## 字符串、字符和字节

  本章节内容较少且主要内容在于介绍各字符或字符串处理函数。

- 最常用的几个字符串函数都是“不受限制的“，即他们只是通过寻找字符串参数结尾的NULL判断它的长度，这些函数一般都指定一块内存用于存放结果字符串。（strcpy,strcat,strcmp）

- 标准库中还含有另一种字符串函数，它们显式地给出处理字符串的长度，在这些函数中，**如果原参数和目标参数发生重叠，其结果就是未定义的。**（strncpy,strncat,strncmp）。由于这种特性，可想而知对于strncpy来说，**它的结果并不会以NUL子节结尾**。但是strncat会直接在目标数组原来的字符串后面复制length个字符，并且会在最后添加一个NUL字符，并不在意目标函数的剩余空间够不够。

- 字符串也有一些查找函数

  | 函数名                                            | 说明                                               |
  | ------------------------------------------------- | -------------------------------------------------- |
  | char *strchr(char const *str,int ch)              | 返回**首次**出现字符ch的指针                       |
  | char *strrchr(char const *str,int ch)             | 返回**最后一次**出现字符ch的指针                   |
  | char *strpbrk(char const *str,char const *group)  | 返回第一个匹配到group中任何一个字符的字符位置      |
  | char *strstr(char const *s1,char const *s2)       | 返回s1中s2第一次出现的位置                         |
  | size_t strspn(char const *str,char const *group)  | 返回str起始部分**匹配**group中任意字符的字符位置   |
  | size_t strcspn(char const *str,char const *group) | 返回str起始部分**不匹配**group中任意字符的字符位置 |
  | char *strtok(char const *str,char const *sep)     | 将str按sep中的字符进行分词                         |

  ```c
  char str[] = "what a pity, Sam. But things always gone, right?";
      static char sep[] = " !?,.";
      char *token;
      for(token = strtok(str,sep);
          token != NULL;
          token = strtok(NULL,sep)
      )
      printf("Next token is : %s\n",token);
  /*输出结果
  Next token is : what
  Next token is : a
  Next token is : pity
  Next token is : Sam
  Next token is : But
  Next token is : things
  Next token is : always
  Next token is : gone
  Next token is : right
  */
  ```

- strtok函数的保存它所处理的函数的局部信息，所以1不能用它同时解析两个字符串，这样会导致程序失败。

- strerror将错误代码作为参数并返回一个用于指向描述错误的**字符串指针**。

- 直接操作字符会降低程序的可移植性if(ch>'=A'&&ch<='Z')在使用ASCII字符集的机器上没有问题，而在使用EBCDIC字符集上的机器上就有逻辑问题了，而if(isupper(ch))在每种机器上都能正确运行。

- 还有一些内存操作的函数，也比较常见（memcpy,memmove,memcmp,memchr,memset）。

## 插话：以下内容都是断续将整本书看完的，在理解上并无之前几章细致。

## 结构和联合

- 对于两个结构完全相同的结构体来说，它们还是会被编译器当作两个截然不同的类型。

- 对于结构指针中成员的访问要注意一点：点操作符的优先级比间接访问优先级高，所以此时必须使用括号保证正确的执行顺序：（*p）.value，或者直接使用箭头操作符：p->value.

- 对于结构的自引用来说，特别注意以下两个例子：

  ```c
  /*非法形式，因为编译器并不知道该类型占用内存的大小,整个声明像是一个无法结束的递归过程*/
  struct SELF_REF1{
  	int a;
  	struct SELF_REF1 b;
  	int C;
  };
  /*合法形式，编译器在结构的长度确定之前就知道指针的长度*/
  struct SELF_REF1{
  	int a;
  	struct SELF_REF1 *b;
  	int C;
  };
  /*这是之前学习链表结构的时候未注意思考过的*/
  ```

- 有时我们在使用结构体时会出现两个结构体相互依赖的结构，但是不试用指针是无法完成这样的操作的，原因有二：

  - 自引
  - 两个结构最先声明的那个结构中会出现一格未被声明的类型

  为解决这个问题，需要在两个结构体中互相声明对方的类型指针，并在第一个结构体声明前对第二个结构体进行不完整声明，如下：

  ```c
  struct B;
  struct A{
  	struct B *partner;
  	/*other declarations*/
  };
  struct B{
  	struct A *partner;
  	/*other declarations*/
  };
  ```

- 这本书日常的奇淫技巧：一个结构体的指针通常不仅指向整个指针也同时指向该结构体的第一个成员，以上面提到的SELF_REF1结构体为例，px是指向它的指针，但用px给一个int型的指针变量*pi赋值则是错误的，正确的做法是可以强制转换类型：pi = (int *)px。奇淫技巧，没啥用，可以直接用pi = &px->a。

- 这点比较细节。对于有边界对齐要求的机器来说，系统禁止编译器在一个结构的起始位置跳过几个字节来满足边界对齐的要求，因此所有结构的其实存储位置必须是结构中边界要求最严格的数据类型所要求的位置，以下例子说明：

  ```c
  struct{
  	char a;
  	int b;
  	char c;
  };
  /*对于该结构来说，结构的存储地址必须整除4，所以它的存储形式类似于下图,但这种方式对存储的利用
  有明显的浪费，所以可以将对类型要求最严格的成员放在结构体首部，如下：*/
  struct{
      int b;
  	char a;
  	char c;
  };
  /*它的存储形式也在下图给出*/
  ```

  ![结构体成员排列对存储的影响](https://cdn.jsdelivr.net/gh/luojunhui1/BlogPicture/Windows/20201002121255.jpg)

  这么做的收益只有在大量定义某结构体时才会明显，不过若需要明确某个结构体变量的实际位置时，字节对齐是必须要考虑的因素，此时可以使用offsetof（type,meber）函数，第一个参数是结构类型，第二个参数是成员名，返回值是该指定成员存储的位置距离结构体开始存储的位置偏移几个子节。

- 位段和联合使用情况较少，不作记录。

## 动态内存分配



- 必须要意识到一点，用户通过malloc函数向系统要求内存的时候，是有失败的可能得，此时malloc函数返回NULL指针。因此，对每一个malloc返回的指针都要进行检查。

- 对于要求边界对齐的机器，malloc函数返回的内存的其实位置将始终能满足对边界对齐要求最严格的类型的要求。（因为malloc参数中并无参数类型，所以它会执行所有数据类型中最严格的边界对齐？一种设想的方法是对要求的内存大小执行对齐？在有些编译器中，它们的方法是要求在使用malloc的时候执行强制转换来获取需要边界对齐的大小，例如：（int*）malloc(size)）。

- calloc函数和realloc函数的函数原型如下：

  ```c
  void *calloc(size_t num_elements,size_t element_size);
  void *realloc(void *ptr, size_t newsize)
  ```

  这两函数平时也用不上，calloc会对分配的内存空间自动初始化为0，并且显示在参数中给出了类型大小，realloc函数为ptr指向的内存重新划分大小，若缩小内存大小，则原内存部分尾部被拿掉，若增大内存，则将新的内存增加到尾部，若原先的内存块无法改变大小，则realloc将分配另一块大小正确的内存，把原内存块的内容复制到新的内存块上。若realloc的第一个参数为NULL,则它的功能与malloc一样。

- 常见的内存分配错误有以下这些：

  - 对NULL指针进行解引用操作
  - 对分配的内存操作时越过边界
  - 释放并非内存分配的内存
  - 试图释放一块动态分配的内存的一部分
  - 释放一块动态内存后试图再次对其操作

  对于第一种错误，也是最常见的错误，书中给出了一种可靠避免这种错误的方式：

  ```c
  "alloc.h"
  /*
  	Define a reliable memory dispatcher
  */
  #include <stdlib.h>
  
  #define malloc        /*相当于禁止直接调用malloc*/
  #define MALLOC(num,type) (type *)alloc((num)*sizeof(type))
  extern void *alloc(size_t size);
  
  "alloc.c"
  /*
  	create a reliable memory dispatcher
  */
  #include <stdio.h>
  #include "alloc.h"
  #undef malloc           /*这里废除之前的malloc宏定义，在这里可以使用malloc函数*/
  
  void *                  /*一种老派的命名规范*/
  alloc(size_t size)
  {
  	void *new_mem;
  	new_mem = malloc(size);
  	if(new_mem==NULL)
  	{
  		printf("Out of memory!\n");
  		exit(1);
  	}
  	return new_mem;
  }
  ```

  下一节：使用结构和指针,未完待续……