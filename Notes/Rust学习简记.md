# Rust 学习简记

## 语言学习

主要还是在[rust官方社区](https://rustwiki.org/)中进行学习。

### 入门指南

rust是一门静态语言，通过toml文件来实现工程的以来控制，官方提供的主要构建工具有rustc和cargo，一般推荐使用cargo来进行项目的构建和依赖控制，rustc的功能还是比较初级，只有编译应该。cargo构建项目会自动给你建一个本地git仓库（当然这其实是可以设置的），主要有以下的常见命令：

```bash
cargo new "project name"
cargo check # 检查代码能否通过编译
cargo build # 可以增加--release选项来优化编译项目
cargo run # 同时构建和运行项目
```

### 通用编程概念

#### 变量和可变性

- rust中创建的变量默认是不可变的，若要使的变量可变需要加入`mut`关键字；
- rust的存在变量遮蔽机制，激发遮蔽机制的关键字是`let`，遮蔽也具有生命周期；
- rust存在常量类型，其机制与作用域与C++类似，**必须说明数据类型**，约定写法格式为`THREE_HOURS_IN_SECONDS`。

#### 数据类型

- 标量类型，包括整形、浮点型、布尔值和字符
- 符合类型，包括元组和数组，元组不要求元素的类型一致但长度不可变，数组要求类型一致而且长度也不可变。元组支持常见的拆装操作，使用`.`来访问元组的元素；数组可以使用`let x:[ type or value; number]`来初始化，通过下标来访问数组元素会进行越界检查；

#### 函数

- rust的函数需要说明参数的类型

- rust中参数的返回值依靠表达式来返回，而不是像c++或python那样通过return语句显示返回。这里拓展出rust的语句（statement）是不返回值的，但是表达式返回值，所以可以这样写：

  ```rust
  let y = {
          let x = 3;
          x + 1
      };
  ```

#### 控制流

- while和if语句的condition不使用`()`包裹，并且`{}`应该是不能省略；
- loop中的break后可以接表达式用于返回值。

#### 认识所有权

- 所有权

  实际上rust中的所有权类似于C++中的作用域，但是所有权在实际实现上有着这样几个明显的特征：

  - 当将一个具有`drop trait`的变量，实际上也就是这个变量存储在堆上，原封不动地赋值给另一个变量时，原变量失效，对其进行操作将会报错，也就是原变量的所有权转移到了新的变量上，这是一种很保守的策略，文档中说是为了避免多个变量指向同一块堆内存导致释放资源时的释放顺序和释放时机难以确定的问题，实际上的一个变量就只有一份所有权，避免了这样的问题；
  - 但是，若变量具有`copy trait`，也即变量存储在栈上，或者手动使用`clone`函数，那么赋值操作确实会将变量的内容再复制一遍；
  - 这样的机制也影响到函数传参，当一个具有`drop trait`形参（parameter）传入到函数中，这个参数的所有权转移到函数内，并且会在函数的末尾执行`drop`函数，除非在函数的返回值中再将这个值返回到上一级的函数空间中，这样就会将变量的所有权再次转移回去。

- 引用

  rust中也存在引用，当使用引用来进行传参时就不用再将变量的所有权击鼓传花传来传去，但是引用的使用也有非常严苛的限制：

  - 首先，引用默认是不可以改变引用值的，类似于C++中的`const int *`；
  - 其次，为了避免数据竞争，也就是避免出现读脏数据、脏写这样的会破环数据同一性的问题，rust不允许一个变量可变引用与其他类型的任何引用同时存在，这样会甚至会无法通过编译；
  - rust不允许垂悬引用的存在，即引用必须是有效的；

- 切片

  
  
  

## 实战经验

